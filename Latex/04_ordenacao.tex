\documentclass[a4paper, twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{color}
\usepackage{a4wide}
\usepackage{float}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{enumerate}
\usepackage{url}
\usepackage{listings}
\usepackage{caption}

\lstset{
	language=Python,
	basicstyle=\small\sffamily,
	numbers=left,
	numberstyle=\tiny,
	xleftmargin = 3em,
	frame=tb,
	columns=fullflexible,
	showstringspaces=false,
}

\graphicspath{ {images/} }
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\title{Algoritmos de ordenação}
\author{Vinicius A. Matias}
\date{\today}
\begin{document}
	\maketitle
	
	\section{Introdução}
	Ordnear elementos de uma estrutura de dados é uma das tarefas mais curiosas e da computação. Diferentes implementações podem ser realizadas, das mais triviais às mais eficientes, assumindo heurísticas dos algoritmos ou não, e cada um dos algoritmos tem seu valor para um melhor entendimento da complexidade computacional.
	
	\section{Insertion Sort}
	O método de ordenação por inserção é um dos maios simples. Ele consiste em verificar de dois em dois elementos se o valor corrente é maior que o valor antecessor no arranjo, e se for, trocar e repetir o processo até o arranjo ficar ordenado.
	
	Esse algoritmo pode ser pensado no caso de segurarmos um conjunto de cartas em uma mão e queiramos ordená-las. Aplicando o algoritmo da ordenação por inserção, verificamos a segunda carta, vemos se a primeira é maior que ela e se sim, trocamos as cartas. Na terceira carta vemos se a segunda é maior, e se for, vericamos se ela também é maior que a primeira. Esse processo é repetido para todas as cartas, passando por cada carta da esquerda para a direita e comparando da direita para a esquerda.
	
	\subsection{Implementação iterativa}	
	
	A implementação do algoritmo iterativo pode ser vista na Listing 1.
		
	Como a operação de interesse desse algoritmo é a comparação entre elementos do arranjo e o valor corrente, devemos identificar que existem dois laços envolvidos para computar essa operação. O laço mais externo roda entre $i=0$ e $i<len(A)$, ou seja, $n-1$ vezes. No melhor dos casos não haverá necessidade de trocar os elementos pois o arranjo já está ordenado, e nesse caso só será realizada uma verificação por volta do laço, levando à $n-1$ iterações no melhor caso. 

\begin{lstlisting}[label=insertion_sort,caption= Insertion Sort iterativo]
def insertion_sort(A):
    end = len(A)
    i = 0
    j = 0

    while i < end:
        value = A[i]
        j = i
        while j>0 and A[j-1] > value:
            A[j] = A[j-1]
            j = j-1
        A[j] = value
        i += 1
    
    return A
\end{lstlisting}	
	
	
	No pior caso, para cada uma das $n-1$ voltas do laço será necessário verificar todos os elementos anteriores à posição atual (segundo laço). Isso implica que a primeira execução fará uma verificação, a segunda duas, a terceira três até a enésima, realizando n comparações. Somando o número de comparações teremos algo como $1+2+3+...+n-1$, que pode ser vista como uma soma de Progressão Aritmética. A soma desta PA que cresce de 1 em um pode ser definida como $\frac{n(0+n-1)}{2} = \frac{n^2-n}{2}$, isto é, o algoritmo de ordenação por inserção iterativo tem crescimento assintótico $\mathcal{O}(n^2)$
	
\subsection{Demonstração de crescimento assintótico $\mathcal{O}(n^2)$}
	
$f(n) = \frac{n^2-n}{2} \in \mathcal{O}(n^2)$ se existem constantes $n_0 \geq 0$ e $c \geq 0$ que satisfazem a inequação:

$0 \leq \frac{n^2-n}{2} \leq cn^2$ \\
 
Resolvendo $0 \leq \frac{n^2-n}{2}$ notamos que a inequação é verdadeira para qualquer $n \in \mathcal{R}$ \\

Resolvendo $\frac{n^2-n}{2} \leq cn^2$:

$\frac{n(n-1)}{2} \leq cn^2$

$\frac{n-1}{2} \leq cn$

$\frac{-1}{2} \leq cn - \frac{n}{2}$

$\frac{-1}{2} \leq n(c - \frac{1}{2})$

Para a inequação ser verdadeira, $c - \frac{1}{2} \geq 0$ deve ser verdade, logo, $c \geq \frac{1}{2}$.

Assim, a inequação $\frac{-1}{2} \leq n(c - \frac{1}{2})$ é verdadeira para qualquer valor $n \geq 0$ e $c \geq \frac{1}{2}$, como exemplo:

$n_0 = 1$ e $c = 1$ \\

Isso prova que $\frac{n^2-n}{2} \in \mathcal{O}(n^2)$

\subsection{Implementação recursiva}	

A listing 2 apresenta uma implementação recursiva do Insertion Sort.

O algoritmo é baseado na indução fraca, garantindo que sabe-se ordenar um arranjo com um elemento, pois ele já está ordenado (caso base). Cada chamada recursiva um dos $n-1$ sub arranjos possíveis.

\begin{lstlisting}[label=insertion_sort_rec,caption= Insertion Sort recursivo]
def insertion_sort_rec(A, n):
    if n == 1: return 

    insertion_sort_rec(A, n-1)
    i = n - 1
    aux = 0

    while i > 0 and A[i-1] > A[i]:
        aux = A[i]
        A[i] = A[i-1]
        A[i-1] = aux
        i -= 1

    return A
\end{lstlisting}
	
Considerando que a operação de interesse é a comparação entre elementos do arranjo $A[i-1] > A[i]$, podemos definir duas equações de recorrência, uma para o melhor caso e outra para o pior caso.

\textbf{Melhor caso: } O arranjo está ordenado, portanto serão feitas $n-1$ chamadas recursivas para um arranjo de tamanho $n$, e uma comparação em cada uma dessas chamadas. Para o caso base não é feita nenhuma comparação entre elementos do arranjo.

$T(n) = \begin{cases} 
	0, \ n  = 1\\
	T(n-1) + 1, \ n > 1
\end{cases}$ \\

A resolução dessa equação de recorrência diz que $T(n) = n - 1$ \\

\textbf{Pior caso: } São feitas $n-1$ comparação para cada $n$ passado na recorrência.

$T(n) = \begin{cases} 
	0, \ n  = 1\\
	T(n-1) + n-1, \ n > 1
\end{cases}$ \\

E a resolução dessa equação de recorrência resulta em $T(n) = (n^2-n)/2$, e que $T(n) \in \mathcal{O}(n^2)$

\subsection{Equação de recorrência para o pior caso}

Demonstraremos que o resultado da equação de recorrência abaixo é $T(n) \in \mathcal{O}(n^2)$ \\

$T(n) = \begin{cases} 
	0, \ n  = 1\\
	T(n-1) + n-1, \ n > 1
\end{cases}$ \\

Notando que $T(n)$ varia as chamadas recursivas de 1 em 1, calcularemos as equações de recorrência para $n-1$, $n-2$ e $n-3$

$T(n) = T(n-1) + n-1$\\

$T(n-1) = T(n-1-1) + n-1-1 = T(n-2) + n - 2$\\

$T(n-2) = T(n-2-1) + n-2-1 = T(n-3) + n - 3$\\

$T(n-3) = T(n-3-1) + n-3-1 = T(n-4) + n - 4$\\

Podemos aplicar esses valores na equação de recorrência $T(n)$:

$T(n) = T(n-1) + n-1$

$T(n) = T(n-2) + n - 2 + n-1$

$T(n) = T(n-2) +2n -2 -1$

$T(n) = T(n-3) + n - 3 +2n -2 -1$

$T(n) = T(n-3) + 3n -3 -2 -1$

$T(n) = T(n-4) + n - 4 + 3n -3 -2 -1$

$T(n) = T(n-4) + 4n -4 -3 -2 -1$

[...]

$T(n) = T(n-i) + in + \sum_{j=1}^{i} -j$

A operação $\sum_{j=1}^{i} -j$ é uma soma de Progressão Aritmética, podendo ser reescrita como $\frac{i*(-1 - i)}{2}$

Assim, $T(n) = T(n-i) + in + \frac{i*(-1 - i)}{2}$

Quando $i = n$: 

$T(n) = T(n-i) + in + \frac{i*(-1 - i)}{2}$

$T(n) = T(n-n) + n^2 + \frac{n*(-1 - n)}{2}$

$T(n) = T(0) + n^2 + \frac{(-n - n^2)}{2}$

$T(n) = n^2 + \frac{(-n - n^2)}{2}$

$T(n) = \frac{(-n - n^2 + 2n^2)}{2}$

$T(n) = \frac{(n^2 - n)}{2}$\\

E como foi demonstrado no item \textbf{2.2}, $\frac{(n^2 - n)}{2} \in \mathcal{O}(n^2)$, portanto: \\

$T(n) \in \mathcal{O}(n^2)$

\section{Selection Sort}
A ordenação por seleção parte do último elemento de um arranjo e compara com todos os anteriores para verificar se há um elemento maior que ele e, caso exista, capturar o maior de todo o subarranjo. O índice do maior valor do subarranjo é capturado e é comparado com o índice elemento que se partiu a ordenação (da direita para a esquerda, então, o último, penúltimo etc) para verificar se são iguais, caso forem iguais não há necessidade de trocar de posições pois ho maior elemento do subarranjo já está mais à direita do arranjo. Caso sejam diferentes, o algoritmo troca a posição do então último elemento do arranjo pelo maior elemento encontrado.

\subsection{Implementação iterativa}

Uma implementação em Python do algoritmo de seleção pode ser vista na Listing 3.

\begin{lstlisting}[label=selection_sort,caption= Selection Sort iterativo]
def selection_sort(A):
    n = len(A)
    fim = n-1

    while fim > 0:
        max = fim
        for j in range(fim):
            if A[j] > A[max]:
                max = j
        if fim != max:
            temp = A[fim]
            A[fim] = A[max]
            A[max] = temp
        fim -= 1

    return A
\end{lstlisting}

A operação de interesse aqui é a comparação entre cada elemento de um subarranjo com o máximo encontrado até então. Note que tanto o loop mais externo quanto o mais interno (que compreende a comparação $A[j] > A[max]$) são executados sempre a mesma quantidade de vezes para um mesmo $n$, implicando que o melhor e o pior caso sejam iguais.

O loop externo é executado $n-1$ vezes e a quantidade de iterações do loop interno segue um progressão aritmética ($n-1$, $n-2$, ..., $2$, $1$). A soma dessas iterações é dada por $\frac{(n-1)*(n-1+1)}{2}$, logo, $\frac{n^2-n}{2}$ comparações para qualquer caso. Isso implica que esta implementação $\in \Theta(n^2)$

\subsection{Implementação recursiva}

Uma implementação recursiva do algoritmo de ordenação por seleção é exibido na Listing 4.

\begin{lstlisting}[label=selection_sort_rec,caption= Selection Sort recursivo]
def selection_sort_rec(A, n):
    if n == 1: return A
    
    max = n-1
    for i in range(n):
        if A[i] > A[max]:
            max = i
    
    if max != n-1:
        temp = A[max]
        A[max] = A[n-1]
        A[n-1] = temp

    return selection_sort_rec(A, n-1)
\end{lstlisting}

Partindo do caso base, sabe-se ordenar um arranjo de apenas um elemento (é o próprio arranjo). Para se ordenar para mais um elemento devem ser seguidas as diretrizes do algoritmo, como foi exibido acima. A equação de recorrência para esse ordenador (para o número de comparações entre elementos do arranjo) pode ser definida como: \\

$T(n) = \begin{cases} 
	0, \ n = 1\\
	T(n-1) + n-1, \ n > 1
\end{cases}$ \\

Levando à $T(n) = \frac{n^2-n}{2}$ e, tanto no melhor quanto no pior caso, à uma implementação $\in \Theta(n^2)$.

\section{Bubble Sort}

O Bubble Sort é possivelmente o método de ordenação mais simples dos aqui estudados, contudo também o método que tem pior desempenho em aplicações reais. O algoritmo consiste em passar por todos os possíveis pares de elementos e comparar se um é maior que o outro. 

\subsection{Implementação iterativa}

O método bolha consiste apenas em uma troca de elementos em pares, uma das implementações iterativas possíveis está na Listing 5.

\begin{lstlisting}[label=bubble_sort,caption= Bubble Sort iterativo]
def bubble_sort(A, n):
    i = n-1
    
    while i > 0:
        j = 1
        while j <= i:
            if A[j-1] > A[j]:
                temp = A[j-1]
                A[j-1] = A[j]
                A[j] = temp
            j += 1
        i -= 1
    
    return A
\end{lstlisting}

Sendo a comparação de interesse destacada em $A[j-1] > A[j]$, assim como no selection sort essa operação será realizada $n-1, n-2, ..., 2, 1$ vezes, mudando agora quais pares de elementos são comparados. A complexidade assintótica se mantém como $\Theta(n^2)$, pois a quantidade de operações segue a mesma soma de PA que resulta em $\frac{(n^2-n)}{2}$.
	
	
\end{document}