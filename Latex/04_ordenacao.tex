\documentclass[a4paper, twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{color}
\usepackage{a4wide}
\usepackage{float}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{enumerate}
\usepackage{url}
\usepackage{listings}
\usepackage{caption}

\lstset{
	language=Python,
	basicstyle=\small\sffamily,
	numbers=left,
	numberstyle=\tiny,
	xleftmargin = 3em,
	frame=tb,
	columns=fullflexible,
	showstringspaces=false,
}

\graphicspath{ {images/} }
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\title{Algoritmos de ordenação}
\author{Vinicius A. Matias}
\date{\today}
\begin{document}
	\maketitle
	
	\section{Introdução}
	Ordnear elementos de uma estrutura de dados é uma das tarefas mais curiosas e da computação. Diferentes implementações podem ser realizadas, das mais triviais às mais eficientes, assumindo heurísticas dos algoritmos ou não, e cada um dos algoritmos tem seu valor para um melhor entendimento da complexidade computacional.
	
	\section{Insertion Sort}
	O método de ordenação por inserção é um dos maios simples. Ele consiste em verificar de dois em dois elementos se o valor corrente é maior que o valor antecessor no arranjo, e se for, trocar e repetir o processo até o arranjo ficar ordenado.
	
	Esse algoritmo pode ser pensado no caso de segurarmos um conjunto de cartas em uma mão e queiramos ordená-las. Aplicando o algoritmo da ordenação por inserção, verificamos a segunda carta, vemos se a primeira é maior que ela e se sim, trocamos as cartas. Na terceira carta vemos se a segunda é maior, e se for, vericamos se ela também é maior que a primeira. Esse processo é repetido para todas as cartas, passando por cada carta da esquerda para a direita e comparando da direita para a esquerda.
	
	\subsection{Implementação iterativa}	
	
	A implementação do algoritmo iterativo pode ser vista na Listing 1.
		
	Como a operação de interesse desse algoritmo é a comparação entre elementos do arranjo e o valor corrente, devemos identificar que existem dois laços envolvidos para computar essa operação. O laço mais externo roda entre $i=0$ e $i<len(A)$, ou seja, $n-1$ vezes. No melhor dos casos não haverá necessidade de trocar os elementos pois o arranjo já está ordenado, e nesse caso só será realizada uma verificação por volta do laço, levando à $n-1$ iterações no melhor caso. 

\begin{lstlisting}[label=insertion_sort,caption= Insertion Sort iterativo]
def insertion_sort(A):
    end = len(A)
    i = 0
    j = 0

    while i < end:
        value = A[i]
        j = i
        while j>0 and A[j-1] > value:
            A[j] = A[j-1]
            j = j-1
        A[j] = value
        i += 1
    
    return A
\end{lstlisting}	
	
	
	No pior caso, para cada uma das $n-1$ voltas do laço será necessário verificar todos os elementos anteriores à posição atual (segundo laço). Isso implica que a primeira execução fará uma verificação, a segunda duas, a terceira três até a enésima, realizando n comparações. Somando o número de comparações teremos algo como $1+2+3+...+n-1$, que pode ser vista como uma soma de Progressão Aritmética. A soma desta PA que cresce de 1 em um pode ser definida como $\frac{n(0+n-1)}{2} = \frac{n^2-n}{2}$, isto é, o algoritmo de ordenação por inserção iterativo tem crescimento assintótico $\mathcal{O}(n^2)$
	
\subsection{Demonstração de crescimento assintótico $\mathcal{O}(n^2)$}
	
$f(n) = \frac{n^2-n}{2} \in \mathcal{O}(n^2)$ se existem constantes $n_0 \geq 0$ e $c \geq 0$ que satisfazem a inequação:

$0 \leq \frac{n^2-n}{2} \leq cn^2$ \\
 
Resolvendo $0 \leq \frac{n^2-n}{2}$ notamos que a inequação é verdadeira para qualquer $n \in \mathcal{R}$ \\

Resolvendo $\frac{n^2-n}{2} \leq cn^2$:

$\frac{n(n-1)}{2} \leq cn^2$

$\frac{n-1}{2} \leq cn$

$\frac{-1}{2} \leq cn - \frac{n}{2}$

$\frac{-1}{2} \leq n(c - \frac{1}{2})$

Para a inequação ser verdadeira, $c - \frac{1}{2} \geq 0$ deve ser verdade, logo, $c \geq \frac{1}{2}$.

Assim, a inequação $\frac{-1}{2} \leq n(c - \frac{1}{2})$ é verdadeira para qualquer valor $n \geq 0$ e $c \geq \frac{1}{2}$, como exemplo:

$n_0 = 1$ e $c = 1$ \\

Isso prova que $\frac{n^2-n}{2} \in \mathcal{O}(n^2)$

\subsection{Implementação recursiva}	

A listing 2 apresenta uma implementação recursiva do Insertion Sort.

O algoritmo é baseado na indução fraca, garantindo que sabe-se ordenar um arranjo com um elemento, pois ele já está ordenado (caso base). Cada chamada recursiva um dos $n-1$ sub arranjos possíveis.

\begin{lstlisting}[label=insertion_sort_rec,caption= Insertion Sort recursivo]
def insertion_sort_rec(A, n):
    if n == 1: return 

    insertion_sort_rec(A, n-1)
    i = n - 1
    aux = 0

    while i > 0 and A[i-1] > A[i]:
        aux = A[i]
        A[i] = A[i-1]
        A[i-1] = aux
        i -= 1

    return A
\end{lstlisting}
	
Considerando que a operação de interesse é a comparação entre elementos do arranjo $A[i-1] > A[i]$, podemos definir duas equações de recorrência, uma para o melhor caso e outra para o pior caso.

\textbf{Melhor caso: } O arranjo está ordenado, portanto serão feitas $n-1$ chamadas recursivas para um arranjo de tamanho $n$, e uma comparação em cada uma dessas chamadas. Para o caso base não é feita nenhuma comparação entre elementos do arranjo.

$T(n) = \begin{cases} 
	0, \ n  = 1\\
	T(n-1) + 1, \ n > 1
\end{cases}$ \\

A resolução dessa equação de recorrência diz que $T(n) = n - 1$ \\

\textbf{Pior caso: } São feitas $n-1$ comparação para cada $n$ passado na recorrência.

$T(n) = \begin{cases} 
	0, \ n  = 1\\
	T(n-1) + n-1, \ n > 1
\end{cases}$ \\

E a resolução dessa equação de recorrência resulta em $T(n) = (n^2-n)/2$, e que $T(n) \in \mathcal{O}(n^2)$

\subsection{Equação de recorrência para o pior caso}

Demonstraremos que o resultado da equação de recorrência abaixo é $T(n) \in \mathcal{O}(n^2)$ \\

$T(n) = \begin{cases} 
	0, \ n  = 1\\
	T(n-1) + n-1, \ n > 1
\end{cases}$ \\

Notando que $T(n)$ varia as chamadas recursivas de 1 em 1, calcularemos as equações de recorrência para $n-1$, $n-2$ e $n-3$

$T(n) = T(n-1) + n-1$\\

$T(n-1) = T(n-1-1) + n-1-1 = T(n-2) + n - 2$\\

$T(n-2) = T(n-2-1) + n-2-1 = T(n-3) + n - 3$\\

$T(n-3) = T(n-3-1) + n-3-1 = T(n-4) + n - 4$\\

Podemos aplicar esses valores na equação de recorrência $T(n)$:

$T(n) = T(n-1) + n-1$

$T(n) = T(n-2) + n - 2 + n-1$

$T(n) = T(n-2) +2n -2 -1$

$T(n) = T(n-3) + n - 3 +2n -2 -1$

$T(n) = T(n-3) + 3n -3 -2 -1$

$T(n) = T(n-4) + n - 4 + 3n -3 -2 -1$

$T(n) = T(n-4) + 4n -4 -3 -2 -1$

[...]

$T(n) = T(n-i) + in + \sum_{j=1}^{i} -j$

A operação $\sum_{j=1}^{i} -j$ é uma soma de Progressão Aritmética, podendo ser reescrita como $\frac{i*(-1 - i)}{2}$

Assim, $T(n) = T(n-i) + in + \frac{i*(-1 - i)}{2}$

Quando $i = n$: 

$T(n) = T(n-i) + in + \frac{i*(-1 - i)}{2}$

$T(n) = T(n-n) + n^2 + \frac{n*(-1 - n)}{2}$

$T(n) = T(0) + n^2 + \frac{(-n - n^2)}{2}$

$T(n) = n^2 + \frac{(-n - n^2)}{2}$

$T(n) = \frac{(-n - n^2 + 2n^2)}{2}$

$T(n) = \frac{(n^2 - n)}{2}$\\

E como foi demonstrado no item \textbf{2.2}, $\frac{(n^2 - n)}{2} \in \mathcal{O}(n^2)$, portanto: \\

$T(n) \in \mathcal{O}(n^2)$

\section{Selection Sort}

\begin{lstlisting}[label=selection_sort,caption= Selection Sort iterativo]
def selection_sort(A):
    n = len(A)
    fim = n-1

    while fim > 0:
        max = fim
        for j in range(fim):
            if A[j] > A[max]:
                max = j
        if fim != max:
            temp = A[fim]
            A[fim] = A[max]
            A[max] = temp
        fim -= 1

    return A
\end{lstlisting}

\end{document}