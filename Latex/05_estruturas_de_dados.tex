\documentclass[a4paper, twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{color}
\usepackage{a4wide}
\usepackage{float}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{enumerate}
\usepackage{url}
\usepackage{listings}
\usepackage{caption}

\lstset{
	language=Python,
	basicstyle=\small\sffamily,
	numbers=left,
	numberstyle=\tiny,
	xleftmargin = 3em,
	frame=tb,
	columns=fullflexible,
	showstringspaces=false,
}

\graphicspath{ {images/} }
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\title{Estruturas de Dados elementares}
\author{Vinicius A. Matias}
\date{\today}
\begin{document}
	\maketitle
	
	\section{Introdução}
	Estruturas de Dados são elementos básicos da computação e essenciais para um desempenho eficiente na manipulação e armazenamento de dados durante a execução de um programa. Cada estrutura tem uma peculariedade, tornando o conhecimento e estudo delas necessário para identificar facilmente qual a melhor opção a se tomar enquanto se desenvolve um algoritmo.
	
	\section{Lista Linear Sequencial}
	Uma lista linear consiste no conceito de que cada elemento tem um predecessor e um sucessor, com exceção do primeiro e último elemento de uma lista. A lista linear sequencial adiciona o fator de um elemento esta na sequencia do outro não somente na visão do programador, mas também na alocação de memória. Note que a maioria das linguagens de programação não permite uma manipulação direta da memória (pelo menos não de forma trivial), tais como Java e Python. A linguagem de programação C é muito relevante para quem tenha interesse de se manipular mais diretamente esses elementos. Para manter a consistência com os outros códigos desenvolvidos, as estruturas de dados serão implementadas também em Python, utilizando objetos.
	
\begin{lstlisting}[label=lista_linear_seq,caption= Lista linear sequencial (estrutura)]
class Registro:
    def __init__(self, id, chave):
        self.id = id
        self.chave = chave

class Lista_Linear_Sequencial:
    def __init__(self, max):
        self.registro = [Registro] * max
        self.n_elementos = -1
        self.max = max
\end{lstlisting}
	
A implementação estática da lista linear sequencial é utilizada para armazenar valores até um limite estabelecido, algo como um arranjo de tamanho pré definido (comum em linguagens como Java e C, mas não tanto em Python). O trecho de código anterior apresenta dois objetos. O primeiro é o Registro, consistindo nos objetos que serão amazenados na Lista (no caso, um campo para o id em inteiros e um campo para a chave em forma de string). A estrutura da lista $Lista\_Linear\_Sequencial$ armazena três atributos: o limite da lista $max$, a quantidade de elementos inseridos na lista $n\_elementos$ e um arranjo de $max$ elementos alocados sequencialmente na memória (fica implicita a alocação em Python) $registro$. Assim que a estrutura é instanciada são reservados $max$ espaços na memória para armazenar cada $registro$, mesmo que nunca sejam usados.

Para inicializar a lista basta zerar a quantidade de elementos visíveis nela.

\begin{lstlisting}[label=lista_linear_seq,caption= Lista linear sequencial (inicialização)]
def inicializar_lista(self):
        self.n_elementos = 0
\end{lstlisting}

A estrutura já armazena a quantidade de elementos adicionados na lista, então para obter o tamanho dela basta retornar este atributo.

\begin{lstlisting}[label=lista_linear_seq,caption= Lista linear sequencial (tamanho)]
def tamanho(self):
         return self.n_elementos
\end{lstlisting}

Para imprimir a lista basta passar sequencialmente em todos os registros de 0 à $n\_elementos-1$

\begin{lstlisting}[label=lista_linear_seq,caption= Lista linear sequencial (exibição)]
def imprimir_lista(self):     
        for i in range(self.n_elementos):
            print("Elemento:", i, 
            "| ID:", self.registro[i].id, 
            "| Chave:", self.registro[i].chave)
\end{lstlisting}

Assim como na impressão, a busca passa por todos os elementos de 0 à $n\_elementos-1$ procurando um registro com a chave igual à uma passada por parâmetro.
\begin{lstlisting}[label=lista_linear_seq,caption= Lista linear sequencial (busca)]
def busca_sequencial(self, chave):
        for i in range(self.n_elementos):
            if self.registro[i].chave == chave:
                return i
        return -1

\end{lstlisting}

Para inserir elementos, partiremos da estratégia de se inserir em uma posição escolhida pelo usuário. Para realizar esse método será necessário primeiramente verificar se é possível inserir um elemento na lista (isto é, se não está cheia) e se a posição solicitada pelo usuário é válida. Havendo possibilidade de inserção, todos os elementos à direita da posição solicitada mudarão suas referências para o índice imediatamente posterior, e com isso é possível inserir o elemento na posição solicitada sem perder os outros elementos previamente inseridos. Note que ao fim da inserção também é necessário aumentar o atributo $n\_elementos$ em um.

\begin{lstlisting}[label=lista_linear_seq,caption= Lista linear sequencial (inserção)]
def inserir_registro(self, registro, posicao):
        if (self.n_elementos == max or 
        posicao < 0 or 
        posicao > self.n_elementos:
            return False

        j = self.n_elementos
        while j > posicao:
            self.registro[j] = self.registro[j-1]
            j -= 1
        self.registro[posicao] = registro
        self.n_elementos += 1
        return True
\end{lstlisting}


\begin{lstlisting}[label=lista_linear_seq,caption= Lista linear sequencial (remoção)]
def excluir_elemento(self, chave):
        posicao = self.busca_sequencial(chave)
        if posicao == -1: return False

        j = posicao
        while j < self.n_elementos-1:
            self.registro[j] = self.registro[j+1]
            j += 1
        self.n_elementos -= 1
        return True
\end{lstlisting}

Para excluir um elemento da lista por meio da chave (passada por parâmetro) utilizamos uma chamada ao método de busca sequencial para verificar se esta chave está na lista e, estando, podemos iniciar o processo de remoção. Como sabemos o índice que o elemento a ser excluído, nós passamos todos os elementos após essa posição para o índice anterior (move todo o arranjo posterior à posição em uma posição para a esquerda). Como movemos todo o arranjo à direita da posição em um índice à menos, a posição à ser excluida foi sobreposta pelo índice até então posterior, portanto perdendo a referência ao elemento e considerando-o excluído. Note que é necessário diminuir em um o atributo com o número de elementos da lista.

A reinicialização dessa estrutura é igual à inicialização, consistindo apenas de zerar o número de elementos válidos. Note que os elementos anteriores continuam alocados na memória, mas a estrutura não consegue mais acessá-los.

\begin{lstlisting}[label=lista_linear_seq,caption= Lista linear sequencial (reinicialização)]
def reinicializar_lista(self):
        self.n_elementos = 0
\end{lstlisting}

\subsection{Lista Linear Sequencial Ordenada}
Note que a busca de qualquer elemento na estrutura mencionada pode assumir complexidade $\mathcal{O}(n)$. Para realizar uma busca mais eficiente, é possivel tomar pelo menos duas abordagens.

Uma delas é adicionar um campo sentinela no arranjo de registros, isto é, alocar espaço para mais um registro no arranjo visando realizar menos comparações na busca sequencial:

\begin{lstlisting}[label=lista_linear_seq_sentinela,caption= Lista linear sequencial com sentinela (estrutura)]
def busca_sentinela(self, id):
        i = 0
        self.registro[self.n_elementos].id = id
        while self.registro[i].id != id: i += 1
        if i == self.n_elementos: return -1        
        return i
\end{lstlisting}

A alteração da estrutura permite a adição de um sentinela durante o processo de busca. Adicionar um sentinela quer dizer que aplicaremos o valor que estamos procurando na última posição válida durante a busca, ou seja, realizando um loop no intervalo $[0, n\_elementos]$, com o valor que procuramos na posição $n\_elementos$. O laço correrá com apenas uma condição (removendo um segundo \textit{if} da busca sequencial primária), pois sabe-se que eventualmente o resultado será verdadeiro.

\begin{lstlisting}[label=lista_linear_seq_sentinela_busca,caption= Lista linear sequencial com sentinela (busca)]
def busca_sentinela(self, id):
        i = 0
        self.registro[self.n_elementos].id = id
        while self.registro[i].id != id: i += 1
        if i == self.n_elementos: return -1        
        return i
\end{lstlisting}

Ainda, a busca pode se tornar mais eficiente ainda se conseguirmos aplicar o método de busca binária. Para aplicá-lo, contudo, é necessário que os elementos estejam ordenados. Para tal, podemos modificar o método de inserção da lista linear sequencial para ordenar os elementos em cada adição. Uma das maneiras é aplicando as premissas do método de ordenação por inserção:

\begin{lstlisting}[label=lista_linear_ord_inserir,caption= Lista linear sequencial ordenada (inserção)]
def inserir_registro_ord(self, registro):
  if self.n_elementos >= self.max:
    return False

  pos = self.n_elementos
  while (pos > 0 and 
  self.registro[pos-1].id > registro.id):
    self.registro[pos] = self.registro[pos-1]
  pos -= 1
  self.registro[pos] = registro
  self.n_elementos += 1
  return True
\end{lstlisting}

Essa ordenação na inserção permite a utilização da busca binária na estrutura de dados criada.

\begin{lstlisting}[label=lista_linear_busca_bin,caption= Lista linear sequencial ordenada (busca binária)]
def busca_binaria(self, id):
  esq = 0
  dir = self.n_elementos-1
     
  while esq <= dir:
    meio = int((esq+dir)/2)
    if self.registro[meio].id == id: return meio 
    elif self.registro[meio].id < id: 
      esq = meio + 1
    else:
      dir = meio -1
  
  return -1 
\end{lstlisting}

Também é possível modificar o método de remoção para realizar a busca binária ao invés da busca sequencial para procurar o elemento na estrutura, contudo, o laço do deslocamento dos elementos domina a complexidade, podendo realizar até $max$ comparações.

\section{Lista Ligada}
Listas ligadas divergem da lista sequencial pois os elementos não são mais alocados sequencialmente, mas sim em endereços de memória dispersos. Essa implementação requer que cada elemento tenha uma referência, ao menos, ao próximo elemento da lista, e portanto devendo se atentar nessa troca de endereços durante inserções e remoções. Falaremos de três maneiras de se implementar uma lista ligada.

\subsection{Implementação Estática}
\begin{lstlisting}[label=lista_ligada_estat_estrutura,caption= Lista Ligada estática ordenada (estrutura)]
MAX = 50

class Registro:
    def __init__(self, id, chave):
        self.id = id
        self.chave = chave

class Elemento:
    def __init__(self, registro, prox):
        self.reg = registro
        self.prox = prox

class Lista:
    def __init__(self):
        self.elemento = [Elemento] * MAX
        self.inicio = None
        self.dispo = None
\end{lstlisting}


Consiste em utilizar um arranjo para persistir os endereços de memória válidos para a estrutura. Nessa implementação o objeto $Registro$ se mantém inalterado, a Lista é alterada e é criado um novo objeto chamada $Elemento$. Cada registro está armazenado em um Elemento, e os elementos possuem além do registro um campo para identificar o índice que está o próximo elemento. A estrutura Lista mantém um arranjo de Elementos, o índice do primeiro elemento (caso haja elementos na lista) e um campo para identificar o próximo elemento disponível na lista (isto é, um índice do arranjo que não tenha nenhum elemento). É utilizada uma constante $MAX$, mas este valor poderia ser parte da estrutura da Lista também, mas não seria tão útil quanto na lista linear sequencial.

A inicialização da lista passa por todos os índices do arranjo de elementos e cria um espaço do tamanho de um registro e adiciona a referência para o próximo elemento do arranjo (índice 0 tem como próximo 1, índice 1 tem como próximo 2 etc) no intervalo $[0,MAX-1]$ o último elemento válido (índice $MAX-1$) não pode ter referência à um próximo, pois não há mais espaço na lista. Como não há nenhum elemento inserido até então, o primeiro registro indicado por $self.inicio$ é nulo e o primeiro elemento disponível para inserção é o índice 0.

\begin{lstlisting}[label=lista_ligada_estat_inicializacao,caption= Lista Ligada estática ordenada (inicialização)]
def inicializar_lista(self):
  for i in range(MAX-1):
    self.elemento[i] = Elemento(Registro, i+1)
  self.elemento[MAX-1].prox = None
  self.inicio = None
  self.dispo = 0
\end{lstlisting}

O tamanho pode ser obtido passando por todos os elementos até encontrar um inválido. Note que não armazenamos o tamanho da lista nessa implementação.
\begin{lstlisting}[label=lista_ligada_estat_tamanho,caption= Lista Ligada estática ordenada (tamanho)]
def tamanho(self):
        i = self.inicio
        tamanho = 0
        while i != None:
            tamanho +=1
            i = self.elemento[i].prox
        return tamanho
\end{lstlisting}

Para visualizar os registros de uma lista podemos seguir uma estratégia semelhante à do tamanho, isto é, de passar por todos os elementos.
\begin{lstlisting}[label=lista_ligada_estat_exibicao,caption= Lista Ligada estática ordenada (exibição)]
def imprimir_lista(self):
  i = self.inicio
  print("Lista de Registros")
  while i != None:
    print("ID:", self.elemento[i].reg.id,
    "Chave:", self.elemento[i].reg.chave)
    i = self.elemento[i].prox
\end{lstlisting}

Ainda que ordenada, não podemos realizar uma busca binária para otimizar a busca sendo que não temos como definir um "meio" da estrutura. Isso leva à implementação da busca sequencial por todos valores menores que um parâmetro.
\begin{lstlisting}[label=lista_ligada_estat_busca,caption= Lista Ligada estática ordenada (busca)]
def busca(self, id):
    i = self.inicio
    while (i != None and 
    self.elemento[i].reg.id < id):
        i = self.elemento[i].prox
    if (i != None and 
    self.elemento[i].reg.id == id):
        return i
\end{lstlisting}

A inserção em uma Lista ligada estática vai requerer um método adicional: $obter\_no()$. Estamos considerando que a inserção será ordenada e não poderá haver dois id's iguais na mesma lista.

\begin{lstlisting}[label=lista_ligada_estat_inserir,caption= Lista Ligada estática ordenada (inserção)]
def obter_no(self):
  resultado = self.dispo
  if self.dispo != None:
  	self.dispo = self.elemento[self.dispo].prox
  return resultado

def inserir(self, reg):
  if (self.dispo == None): return False
  ant = None
  i = self.inicio
  id = reg.id
  while (i != None and self.elemento[i].reg.id < id):
    ant = i
    i = self.elemento[i].prox
  if (i != None and self.elemento[i].reg.id == id): 
  	return False
  i = self.obter_no()
  self.elemento[i].reg = reg
  if ant == None:
    self.elemento[i].prox = self.inicio
    self.inicio = i
  else:
    self.elemento[i].prox = self.elemento[ant].prox
    self.elemento[ant].prox = i
  return True
\end{lstlisting}

Havendo espaço na lista ligada, percorreremos todos os elementos até econtrar um id maior ou igual ao que queremos inserir \textbf{ou} o último elemento válido da lista. No loop nós armazenamos o endereço do último elemento do laço \textbf{e} o endereço do elemento anterior à ele, isto é, o que aponta para ele. Na sequencia é feita uma comapração para verificar se o enderço do elemento é válido e se o id do registro é igual ao id solicitado para inclusão, se qualquer um dos testes forem verdadeiros, nós não inserimos o registro na lista. Estando tudo ok, chamamos a função de obter nó, retornando o próximo espaço do arranjo disponível para inserção, atualizando também o índice sem alocamento ($dispo$) para o próximo da lista (o que ele apontava). Adicionado, podemos verificar se o elemento à ser inserido é o primeiro da lista, e se for adicionamos na posição 0 e atualizamos o ponteiro $inicio$ do objeto Lista para a nova referência. Se o elemento precisa ser inserido em uma posição que não a primeira, mudamos o ponteiro do anterior (que estavamos armazenando desde o primeiro loop) para o novo registro, e o ponteiro de próximo do novo registro vai para o que era o próximo do anterior.

\begin{lstlisting}[label=lista_ligada_estat_remover,caption= Lista Ligada estática ordenada (remoção)]
def devolver_no(self, posicao):
  self.elemento[posicao].prox = self.dispo
  self.dispo = posicao

def excluir(self, id):
  ant = None
  i = self.inicio
  while (i != None and 
  self.elemento[i].reg.id < id):
    ant = i
    i = self.elemento[i].prox
  if (i == None or self.elemento[i].reg.id != id): 
  	return False
  if ant == None:
    self.inicio = self.elemento[i].prox
  else: 
    self.elemento[ant].prox = self.elemento[i].prox        
  self.devolver_no(i)
  return True
\end{lstlisting}

A exclusão de um elemento em uma lista ligada ordenada segue o mesmo paradigma que a inserção, notando que quando encontrado um índice para ser removido deva ser perdida a referência à esse elemento, podendo ser feita por meio do ponteiro anterior ao elemento a ser removido começar a apontar ao que era o próximo do elemento a ser excluído. Note que também é necessário atualizar os nós disponíveis, e isso pode ser feito pelo método $develover\_no()$, levando o índice do elemento excluído ao atributo $dispo$ da lista.

A reinicialização da estrutura deve limpar os registros armazenados e atualizar os atributos para uma lista totalmente nova, ou seja, chamando o método de inicialização novamente.

\begin{lstlisting}[label=lista_ligada_estat_reiniciar,caption= Lista Ligada estática ordenada (reinicialização)]
def reinicializar_lista(self):
        self.inicializar_lista()
\end{lstlisting}

\subsection{Implementação Dinâmica}
A implementação dinâmica de uma lista ligada acaba sendo o mais viável computacionalmente. Essa estrutura não deixa alocado um espaço para $n$ registros como nas estruturas vistas até agora, mas aloca cada elemento sob demanda. Para isso ela mantém a estrutura \texttt{Elementos}, e tem uma adaptação na estrutura básica da lista, armazenando por padrão apenas a referêcia ao primeiro elemento da lista.

\begin{lstlisting}[label=lista_ligada_din_estrutura,caption= Lista Ligada dinâmica (estrutura)]
class Registro:
    def __init__(self, id, chave):
        self.id = id
        self.chave = chave

class Elemento:
    def __init__(self, registro, prox):
        self.reg = registro
        self.prox = prox

class Lista:
    def __init__(self):
        self.inicio = None        
\end{lstlisting}

A inicialização da lista pode ter diferenetes implementações dependendo da linguagem de programação, mas em Python simplimente não haverá diferença entre a criação da estrutura e a inicialização por um outro método.

\begin{lstlisting}[label=lista_ligada_din_inicializar, caption= Lista Ligada dinâmica (inicialização)]
def inicializar_lista(self):
   self.inicio = None
\end{lstlisting}

Para o tamanho, porém, será necessário contar todos os elementos da lista, isto é, passar para o próximo elemento apontado por um anterior, até chegar ao último elemento válido (diferente de \texttt{None}). Vale lembrar que cada registro está dentro de uma estrutura (em Python são objetos mesmo) elemento.

\begin{lstlisting}[label=lista_ligada_din_tamanho, caption= Lista Ligada dinâmica (tamanho)]
def tamanho(self):
    endereco = self.inicio
    tamanho = 0
    while endereco != None:
        tamanho += 1
        endereco = endereco.prox
    return tamanho
\end{lstlisting}

A exibição dos elementos segue a mesma lógica que a usada para encontrar o tamanho da lista, mas aqui são utilizados os registros dentro de cada elemento.

\begin{lstlisting}[label=lista_ligada_din_exibir, caption= Lista Ligada dinâmica (exibição)]
def imprimir_lista(self):
    endereco = self.inicio
    print("Lista de Registros")
    while endereco != None:
        print("ID:", endereco.reg.id, 
        "Chave:", endereco.reg.chave)
        endereco = endereco.prox
\end{lstlisting}

Em uma estrutura de lista não ordenada, a busca pode ser implementada buscando, em cada elemento válido, se o registro tem o campo correspondente ao buscado.

\begin{lstlisting}[label=lista_ligada_din_busca, caption= Lista Ligada dinâmica (busca sequencial)]
def busca(self, chave):
    posicao = self.inicio
    while posicao != None:
        if posicao.reg.chave == chave:
            return posicao
        posicao = posicao.prox
    return None
\end{lstlisting}

Porém, podemos adaptar o método de busca sequencial acima para outra busca sequencial que retorna também o elemento anterior ao buscado. Essa manobra é importante para se fazer uma inserção mais eficiente.

\begin{lstlisting}[label=lista_ligada_din_busca_dupla, caption= Lista Ligada dinâmica (busca o anterior e atual)]
    def busca_dupla(self, chave):
        atual = self.inicio
        anterior = None
        while atual != None:
            if atual.reg.chave == chave:
                return anterior, atual
            anterior = atual
            atual = atual.prox
        return anterior, None
\end{lstlisting}

Com auxílio da busca que retorna além do elemento visado, também seu anterior, podemos utilizá-la para verificar se a inserção é viável. Se existirem dois elmentos de mesma chave nós não iremos inserí-lo na estrutura, caso contrário a inserção é possível e devemos verificar se o elemento entrará na primeira "alocação" da lista (quando não há um anterior) ou se entrará em qualquer outra posição. Ajustamos os ponteiros para o caso que se enquadrar e a estrutura terá o novo elemento disponível para aceso na lista.

\begin{lstlisting}[label=lista_ligada_din_inserir, caption= Lista Ligada dinâmica (inserção)]
def inserir(self, reg):
    chave = reg.chave
    anterior, atual = self.busca_dupla(chave)
    if atual != None: return False
    if anterior == None:
        novo = Elemento(reg, l.inicio)
        self.inicio = novo
    else:
        novo = Elemento(reg, anterior.prox)
        anterior.prox = novo        
    return True
\end{lstlisting}

A remoção de elementos também utiliza a referência ao elemento anterior ao buscado, e uma troca entre ponteiros simples (anterior passa a apontar ao que seria o próximo do elemento removido, perdendo a referência).

\begin{lstlisting}[label=lista_ligada_din_excluir, caption= Lista Ligada dinâmica (remoção)]
def excluir(self, chave):
    anterior, atual = self.busca_dupla(chave)
    if atual == None: return False
    if anterior == None: 
        self.inicio = atual.prox
    else: 
        anterior.prox = atual.prox
    return True
\end{lstlisting}

A reinicialização ideal deve exluir todos os elementos alocados anteriormente na memória. Isso fica mais claro em C, mas em Python é possível que percarmos a referência aos elementos e, de tempos em tempos, o Garbage Collector removerá os valores alocados nesses endereços de memória.

\begin{lstlisting}[label=lista_ligada_din_reiniciar, caption= Lista Ligada dinâmica (reinicialização)]
def reinicializar_lista(self):
    self.inicio = None
\end{lstlisting}


\subsection{Implementação Circular com nó-cabeça}
Uma lista ligada circular facilita o percorrimento de uma lista no sentido de nunca haver um elemento nulo à ser acessado. Isso pode economizar operações em laços, aliàda a abordagem de nó cabeça na lista. Esse "nó" funciona como um sentinela, pois não é um elemento que deva entrar na lista acessível ao usuário, mas é implementado como se fosse, de modo a contribiuir na redução da quantidade de operações. As estruturas usadas são as mesmas da lista dinâmica, somente com a mudança no nome da variável \texttt{inicio} para \texttt{cabeca} na estrutura da lista.

\begin{lstlisting}[label=lista_ligada_circ_estrutura, caption= Lista Ligada circular (estrutura)]
class Registro:
    def __init__(self, id, chave):
        self.id = id
        self.chave = chave

class Elemento:
    def __init__(self, reg, prox):
        self.reg = reg
        self.prox = prox

class Lista:
    def __init__(self):
        self.cabeca = None
\end{lstlisting}

A inicialização dessa estrutura aloca espaco para um registro e um elemento no nó cabeça, sendo essa posição para um elemento o próximo nó. Como a lista só tem esse nó cabeça como elemento, o próximo deverá apontar para sí mesmo (por isso a lista é circular).

\begin{lstlisting}[label=lista_ligada_circ_inicializar, caption= Lista Ligada circular (inicialização)]
def inicializar_lista(self):
    self.cabeca = Elemento(Registro, Elemento)
    self.cabeca.prox = self.cabeca
\end{lstlisting}

Para recuperar o tamanho da lista utilizamos a mesma abordage da lista dinâmica apresentada anteriormente.
\begin{lstlisting}[label=lista_ligada_circ_tamanho, caption= Lista Ligada circular (tamanho)]
def tamanho(self):
    i = self.cabeca.prox
    tam = 0
    while i != self.cabeca:
        tam += 1
        i = i.prox
    return tam
\end{lstlisting}

A exibição também segue a implementação da lista dinâmica, e é bem parecida com a função para recuperar o tamanho.
\begin{lstlisting}[label=lista_ligada_circ_exibir, caption= Lista Ligada circular (exibição)]
def imprimir_lista(self):
    i = self.cabeca.prox
    print("Lista de Registros")
    while i != self.cabeca:
        print("ID: ", i.reg.id, "Chave: ", i.reg.chave)
        i = i.prox
\end{lstlisting}

A busca em uma lista ordenada pode se aproveitar do fato de que o nó cabeça funciona como um sentinela para as listas estudadas anteriormente. Nesse caso podemos usar apenas uma condição para girar o loop, pois sabemos que em algum momento a condição falhará e segará no sentinela / nó cabeça.
\begin{lstlisting}[label=lista_ligada_circ_busca, caption= Lista Ligada circular (busca)]
def busca_sentinela(self, id):
    i = self.cabeca.prox
    self.cabeca.reg.id = id
    while i.reg.id < id:
        i = i.prox
    if i != self.cabeca and i.reg.id == id: return i
    return None
\end{lstlisting}

A estrutura de busca apresentada acima pode ser adaptada para retornar também o elemento anterior ao buscado.
\begin{lstlisting}[label=lista_ligada_circ_busca_dupla, caption= Lista Ligada circular (busca anterior e atual)]
def busca_dupla(self, id):
    anterior = self.cabeca
    i = self.cabeca.prox
    self.cabeca.reg.id = id
    while i.reg.id < id:
        anterior = i
        i = i.prox
    if i != self.cabeca and i.reg.id == id: 
        return anterior, i
    return anterior, None
\end{lstlisting}

O conhecimento do elemento anterior e a utilização do nó cabeça permite uma redução significativa no algoritmo apra inserção comparado à lista dinâmica sem nó cabeça. Nessa estrutura não precisamos nos preocupar com o primeiro nó da lista e seu anterior, pois o nó cabeça irá controlar os extremos da lista.
\begin{lstlisting}[label=lista_ligada_circ_inserir, caption= Lista Ligada circular (inserção)]
def inserir(self, reg):
    anterior, i = self.busca_dupla(reg.id)
    if i != None: return False
    novo = Elemento(reg, anterior.prox)
    anterior.prox = novo
\end{lstlisting}

A remoção apenas troca os ponteiros do elemento anterior ao ser excluído para o próximo do que está dando tchau.
\begin{lstlisting}[label=lista_ligada_circ_excluir, caption= Lista Ligada circular (remoção)]
def excluir(self, id):
    anterior, i = self.busca_dupla(id)
    if i == None: return False
    anterior.prox = i.prox
    del i
    return True
\end{lstlisting}

A reinicialização em Python segue os mesmos princípios comentados na estrutura dinâmica de lista ligada.
\begin{lstlisting}[label=lista_ligada_circ_reinicializar, caption= Lista Ligada circular (reinicialização)]
def reinicializar_lista(self):
    self.cabeca.prox = self.cabeca
\end{lstlisting}

\section{Pilha}
Pilhas são estruturas de dados que seguem o princípio de que cada elemento novo inserido ficará no topo da estrutura, isto é, será o primeiro a sair em uma remoção (Last In First Out). Não há muito sentido em se fazer consultas à elementos nessa estruturas, portanto elas não são otimizadas para uma busca eficiente.

\subsection{Implementação estática}

A implementação estática depende, assim como nas listas, de um arranjo auxiliar para armazenar os valores acessíveis. A inicialização da pilha já pode ser definida pela função \texttt{\_\_init\_\_}, que é o construtor de um objeto em Python. Nossa estrutura consiste então de um arranjo de \texttt{MAX} valores e uma variável para indicar o topo (limite) da pilha.

\begin{lstlisting}[label=pilha_estrutura, caption= Pilha estática (estrutura)]
MAX = 50

class Registro:
    def __init__(self, id, chave):
        self.id = id
        self.chave = chave

class Pilha:
    def __init__(self):
        self.reg = [Registro] * MAX
        self.topo = -1
\end{lstlisting}

Como temos o topo da pilha conhecido, podemos descobrir o tamanho da estrutura adicionando 1 ao topo.
\begin{lstlisting}[label=pilha_tamanho, caption= Pilha estática (tamanho)]
def tamanho(self):
    return self.topo + 1
\end{lstlisting}


A impressão dos valores consiste em passar sequencialmente por todos os elementos, como de praxe.
\begin{lstlisting}[label=pilha_imprimir, caption= Pilha estática (exibição)]
def imprimir(self):
    print("PILHA:")
    i = self.topo
    while i >= 0:
        print("ID", self.reg[i].id,
        "Chave:", self.reg[i].chave)
        i -= 1
\end{lstlisting}

A inserção em uma pilha também é chamada de \textit{PUSH}. Bsata apenas adicionar um elemento na posição indicada pelo topo da pilha.
\begin{lstlisting}[label=pilha_inserir, caption= Pilha estática (inserção)]
def push(self, reg):
    if self.topo >= MAX-1: return False
    self.topo = self.topo + 1
    self.reg[self.topo] = reg
    return True
\end{lstlisting}

Para remover (operação também chamada de \textit{POP}) basta encontrar o topo e reduzir em 1 o valor dele, assim o elemento que estava na sequência estará inacessível e suscetível à sobrescrita.
\begin{lstlisting}[label=pilha_remover, caption= Pilha estática (remoção)]
def pop (self):
    if self.topo == -1: return False
    removed = self.reg[self.topo]
    self.topo = self.topo - 1
    return removed
\end{lstlisting}

Para reinicializar uma pilha estática basta mudar o valor do topo para -1.
\begin{lstlisting}[label=pilha_tamanho, caption= Pilha estática (reinicializar)]
def reinicializar(self):
    self.topo = -1
\end{lstlisting}

\subsection{Implementação dinâmica}

\section{Deque}

\section{Fila}

\subsection{Implementação estática}

\subsection{Implementação dinâmica}

\section{Matrizes esparsas}

\end{document}